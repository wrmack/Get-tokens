//
//  CreatePasteBinInteractor.swift
//  POD browser
//
//  Created by Warwick McNaughton on 12/01/19.
//  Copyright (c) 2019 Warwick McNaughton. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import JavaScriptCore


protocol CreatePasteBinBusinessLogic {
    func createBin(request: CreatePasteBin.Something.Request)
}

protocol CreatePasteBinDataStore {
  //var name: String { get set }
}

class CreatePasteBinInteractor: CreatePasteBinBusinessLogic, CreatePasteBinDataStore {
    var presenter: CreatePasteBinPresentationLogic?
    var context: JSContext?


    // MARK: VIP

    func createBin(request: CreatePasteBin.Something.Request) {
        if context == nil { setupContext(); setupRdfLib()}
        
        _ = "https://wrmack.inrupt.net/Public/bins/"
        let title = "Test title"
        let body = "Test body"
        self.context?.evaluateScript("var title = '" + title + "';")
        self.context?.evaluateScript("var body = '" + body + "';")
        self.context?.evaluateScript("var store = RDF.graph();")
        self.context?.evaluateScript("var thisResource = RDF.sym('https://wrmack.inrupt.net/public/');")
        self.context?.evaluateScript("var sioc = new RDF.Namespace('http://rdfs.org/sioc/ns#');")
        self.context?.evaluateScript("var dc = new RDF.Namespace('http://purl.org/dc/terms/');")
        self.context?.evaluateScript("store.add(thisResource, dc('title'), RDF.lit(title));")
        self.context?.evaluateScript("store.add(thisResource, sioc('content'), RDF.lit(body));")
        self.context?.evaluateScript("var data = new RDF.Serializer(store).toN3(store);")
        
        let dataString = self.context?.objectForKeyedSubscript("data")?.toString()

        let url = URL(string: "https://wrmack.inrupt.net/public/")!
//        let url = URL(string: "https://192.168.1.24:8443")!
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
//        request.setValue("text/turtle", forHTTPHeaderField: "Content-Type")
//        request.httpBody = dataString?.data(using: .utf8)
        
        fetch(urlRequest: request, callback: { (data, type) in
            print("Data \(data), type \(type)")
            
            
            let response = CreatePasteBin.Something.Response()
            self.presenter?.presentSomething(response: response)
        
        })
        
    }
    
    
    // MARK: - Helpers
    
    /*
     Setup the javascript context
     */
    func setupContext() {
        
        context = JSContext()
        
        // Catch JavaScript exceptions
        context!.exceptionHandler = { context, error in
            print("JS Error: \(error!)")
        }
        
        let nativePrint: @convention(block) (String) -> Void = { message in
            print("JS print: \(message)")
        }
        context!.setObject(nativePrint, forKeyedSubscript: "nativePrint" as NSString)
    }
    
    
    /*
     Write the bundled javascript RDF library into the javascript context.
     Note: the bundle was created with browserify standalone option set to "RDF".
     All exports in index.js are available to Swift through RDF.
     Setup the store in javascript.
     */
    func setupRdfLib() {
        
        guard let rdfPath = Bundle.main.path(forResource: "rdfbundle", ofType: "js")
            else { print("Unable to read resource files."); return }
        
        do {
            let jsCode = try String(contentsOfFile: rdfPath, encoding: String.Encoding.utf8)
            _ = context?.evaluateScript(jsCode)
            _ = context?.evaluateScript("var store = RDF.graph();")
        }
        catch {
            print("Evaluate script failed")
        }
    }
    
    
    /*
     Url fetcher with callback
     */
    func fetch(urlRequest: URLRequest, callback: @escaping (String, String) -> Void) {
         var newUrlRequest = urlRequest
        
        let authState = AuthState.loadState()
        let currentAccessToken = authState!.lastTokenResponse!.accessToken

        let tokenManager = TokenManager(authState: authState!)
        tokenManager.performActionWithFreshTokens(){ accessToken, idToken, error in
                    
            if error != nil  {
                print("Error fetching fresh tokens: \(error?.localizedDescription ?? "ERROR")")
                return
            }
            
            guard let accessToken = accessToken else {
                print("Error getting accessToken")
                return
            }
            
            if currentAccessToken != accessToken {
                print("Access token was refreshed automatically (\(currentAccessToken ?? "CURRENT_ACCESS_TOKEN") to \(accessToken))")
            } else {
                print("Access token was fresh and not updated \(accessToken)")
            }
            
           
//            urlRequest.allHTTPHeaderFields = ["Authorization":"Bearer \(accessToken)"]
            newUrlRequest.setValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")

            let task = URLSession.shared.dataTask(with: newUrlRequest) { data, response, error in
                
                DispatchQueue.main.async {
                    
                    guard error == nil else {
                        print("HTTP request failed \(error?.localizedDescription ?? "ERROR")")
                        return
                    }
                    
                    guard let response = response as? HTTPURLResponse else {
                        print("Non-HTTP response")
                        return
                    }
                    
                    guard let data = data else {
                        print("HTTP response data is empty")
                        return
                    }
                    
                    var json: [AnyHashable: Any]?
                    
                    do {
                        json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any]
                    } catch {
                        print("JSON Serialization Error")
                    }
                    
                    if response.statusCode != 200 {
                        // server replied with an error
                        let responseText = String(data: data, encoding: String.Encoding.utf8)
                        
                        if response.statusCode == 401 {
                            // "401 Unauthorized" generally indicates there is an issue with the authorization
                            // grant. Puts OIDAuthState into an error state.
                            let oauthError = ErrorUtilities.resourceServerAuthorizationError(code: 0,
                                                                                                errorResponse: json,
                                                                                                underlyingError: error as NSError?)
                            authState?.update(withAuthorizationError: oauthError)
                            print("Authorization Error (\(oauthError)). Response: \(responseText ?? "RESPONSE_TEXT")")
                        } else {
                            print("HTTP: \(response.statusCode), Response: \(responseText ?? "RESPONSE_TEXT")")
                        }
                        
                        return
                    }
                    if let json = json {
                        print("Success: \(json)")
                    }
                }
            }
            
            task.resume()
        }

        
//        let task = URLSession.shared.dataTask(with: urlRequest, completionHandler: { data, response, error in
//
//            if let error = error {
//                print(error)
//                return
//            }
//            print("\nResponse:\n\(response! as Any)")
//            guard let httpResponse = response as? HTTPURLResponse,
//                (200...299).contains(httpResponse.statusCode) else {
//                    print("Server error: \((response as? HTTPURLResponse)?.allHeaderFields as! [String : Any] )")
//                    return
//            }
////            if let mimeType = response!.mimeType,
////                mimeType == "text/turtle",
////                let data = data,
////                let dataString = String(data: data, encoding: .utf8) {
////                print ("got data: \(dataString)")
////            }
//            print("\nAll headers:\n\(httpResponse.allHeaderFields as! [String : Any])")
//
//            let string = String(data: data!, encoding: .utf8)
//            callback(string!, httpResponse.mimeType!)
//        })
//        task.resume()
    }

}
